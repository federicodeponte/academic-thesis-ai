#!/usr/bin/env python3
"""
ABOUTME: Post-processor for DOCX files to add advanced formatting features
ABOUTME: Fixes page numbers, TOC, spacing, indents, section/page breaks after Pandoc generation
"""

from pathlib import Path
from typing import List, Optional
from docx import Document
from docx.shared import Pt, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
from docx.enum.section import WD_SECTION


class DOCXPostProcessor:
    """
    Post-processes DOCX files generated by Pandoc to add features that Pandoc can't create:
    - Page numbers (Roman for front matter, Arabic for content)
    - Table of Contents with clickable links
    - Proper line spacing and indentation
    - Section breaks for different page numbering
    - Page breaks before major sections
    """

    def __init__(self, docx_path: Path):
        """Initialize with path to DOCX file."""
        self.docx_path = docx_path
        self.doc = Document(str(docx_path))

    def _get_style_by_name(self, name: str):
        """Get style by name, handling style name variations."""
        for style in self.doc.styles:
            if style.name == name and style.type == 1:  # Paragraph style
                return style
        return None

    def process(self) -> bool:
        """
        Run all post-processing steps in correct order.

        Returns:
            bool: True if successful, False otherwise
        """
        try:
            print(f"\nüìù Post-processing DOCX: {self.docx_path.name}")
            print()

            # Step 1: Fix paragraph formatting (spacing, indent)
            print("1. Fixing line spacing and indentation...")
            self._fix_paragraph_formatting()

            # Step 2: Insert page break after cover page
            print("2. Separating cover page...")
            self._insert_cover_page_break()

            # Step 3: Insert Table of Contents
            print("3. Adding Table of Contents...")
            self._insert_table_of_contents()

            # Step 4: Insert page breaks before major sections
            print("4. Adding page breaks before major sections...")
            self._insert_section_page_breaks()

            # Step 5: Add section breaks for different page numbering
            print("5. Adding section breaks for page numbering...")
            self._insert_section_breaks()

            # Step 6: Add page numbers
            print("6. Adding page numbers...")
            self._add_page_numbers()

            # Save changes
            self.doc.save(str(self.docx_path))

            print()
            print(f"‚úÖ Post-processing complete: {self.docx_path}")
            return True

        except Exception as e:
            print(f"‚ùå Post-processing failed: {str(e)}")
            import traceback
            traceback.print_exc()
            return False

    def _fix_paragraph_formatting(self):
        """Fix line spacing (2.0) and first-line indent (0.5") for Normal paragraphs."""
        count = 0
        for para in self.doc.paragraphs:
            # Apply to Normal and Body Text styles
            if para.style.name in ['Normal', 'Body Text', 'First Paragraph']:
                pf = para.paragraph_format
                pf.line_spacing = 2.0  # Double spacing
                pf.first_line_indent = Inches(0.5)  # APA standard indent
                pf.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY  # Justified text
                count += 1

        print(f"   ‚úì Fixed {count} paragraphs (2.0 spacing, 0.5\" indent, justified)")

    def _insert_cover_page_break(self):
        """Insert page break after Date paragraph to separate cover page."""
        # Find Date paragraph (usually index 3: Title, Subtitle, Author, Date)
        for i, para in enumerate(self.doc.paragraphs):
            if para.style.name == 'Date' or (i <= 5 and 'date' in para.text.lower()):
                # Insert page break on NEXT paragraph (after Date)
                if i + 1 < len(self.doc.paragraphs):
                    self.doc.paragraphs[i + 1].paragraph_format.page_break_before = True
                    print(f"   ‚úì Inserted page break before paragraph {i+1} (after Date)")
                return

        # Fallback: insert on 5th paragraph if no Date style found
        if len(self.doc.paragraphs) > 4:
            self.doc.paragraphs[4].paragraph_format.page_break_before = True
            print(f"   ‚úì Inserted page break before paragraph 4 (fallback)")

    def _insert_table_of_contents(self):
        """Insert Table of Contents after cover page using Word field code."""
        # Find insertion point (after cover page break, before Abstract)
        insert_index = None
        for i, para in enumerate(self.doc.paragraphs):
            if para.style.name in ['Heading 2', 'Abstract']:
                insert_index = i
                break

        if insert_index is None:
            print("   ‚ö†Ô∏è  Could not find insertion point for TOC (skipping)")
            return

        # Insert TOC heading
        toc_heading = self.doc.paragraphs[insert_index].insert_paragraph_before()
        toc_heading.text = "Table of Contents"
        toc_heading.alignment = WD_ALIGN_PARAGRAPH.CENTER

        # Make heading bold and larger
        if toc_heading.runs:
            run = toc_heading.runs[0]
            run.font.bold = True
            run.font.size = Pt(14)
            run.font.name = 'Times New Roman'

        # Insert TOC field
        toc_para = self.doc.paragraphs[insert_index + 1].insert_paragraph_before()
        self._add_toc_field(toc_para)

        # Add page break on next paragraph (after TOC)
        # This will make Abstract start on new page
        if insert_index + 2 < len(self.doc.paragraphs):
            self.doc.paragraphs[insert_index + 2].paragraph_format.page_break_before = True

        print(f"   ‚úì Inserted Table of Contents before paragraph {insert_index}")

    def _add_toc_field(self, paragraph):
        """
        Add a TOC field to the given paragraph.

        Word TOC field format: { TOC \\o "1-3" \\h \\z \\u }
        - \\o "1-3": Include heading levels 1-3
        - \\h: Make entries hyperlinks
        - \\z: Hide tab leader and page numbers in web view
        - \\u: Use outline levels
        """
        run = paragraph.add_run()

        # Create field begin tag
        fldChar_begin = OxmlElement('w:fldChar')
        fldChar_begin.set(qn('w:fldCharType'), 'begin')

        # Create instruction text
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'TOC \\o "1-3" \\h \\z \\u'

        # Create field end tag
        fldChar_end = OxmlElement('w:fldChar')
        fldChar_end.set(qn('w:fldCharType'), 'end')

        # Add to run
        run._r.append(fldChar_begin)
        run._r.append(instrText)
        run._r.append(fldChar_end)

    def _insert_section_page_breaks(self):
        """Insert page breaks before major sections (Abstract, Introduction, etc.)."""
        major_sections = [
            'Abstract',
            'Introduction',
            'Literature Review',
            'Theoretical Framework',
            'Methodology',
            'Research Design',
            'Findings',
            'Results',
            'Analysis',
            'Discussion',
            'Conclusion',
            'References',
            'Bibliography',
            'Appendix'
        ]

        count = 0
        for para in self.doc.paragraphs:
            # Check if this is a Heading 2 (major section)
            if para.style.name == 'Heading 2':
                # Check if text matches major section titles
                para_text = para.text.strip()
                if any(section.lower() in para_text.lower() for section in major_sections):
                    para.paragraph_format.page_break_before = True
                    count += 1

        print(f"   ‚úì Added page breaks before {count} major sections")

    def _insert_section_breaks(self):
        """
        Insert section breaks to enable different page numbering:
        - Section 1: Front matter (cover + TOC) - Roman numerals
        - Section 2: Main content - Arabic numerals
        """
        # Find where main content starts (after TOC, at Abstract or Introduction)
        main_content_para_index = None

        for i, para in enumerate(self.doc.paragraphs):
            if para.style.name == 'Heading 2' and 'abstract' in para.text.lower():
                main_content_para_index = i
                break

        if main_content_para_index is None:
            print("   ‚ö†Ô∏è  Could not find main content start (skipping section breaks)")
            return

        # Insert section break before Abstract
        # Note: python-docx doesn't easily support inserting section breaks mid-document
        # So we'll work with existing sections and modify their settings

        # For now, we'll note this limitation
        print(f"   ‚ö†Ô∏è  Section breaks require manual insertion in Word")
        print(f"      (Insert ‚Üí Break ‚Üí Next Page before paragraph {main_content_para_index})")

    def _add_page_numbers(self):
        """
        Add page numbers to footer.

        Note: Ideally we'd have:
        - Section 1 (front matter): Roman numerals (i, ii, iii, iv)
        - Section 2 (main content): Arabic numerals (1, 2, 3...)

        Due to python-docx limitations with section breaks, we'll add simple
        Arabic page numbers for now. Users can customize in Word if needed.
        """
        # Add page number field to first section footer
        for section in self.doc.sections:
            footer = section.footer

            # Clear existing footer content
            for para in footer.paragraphs:
                para.clear()

            # Add centered paragraph with page number
            footer_para = footer.paragraphs[0]
            footer_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

            # Add page number field
            self._add_page_number_field(footer_para)

        print(f"   ‚úì Added page numbers to {len(self.doc.sections)} section(s)")
        print("   ‚ÑπÔ∏è  To add Roman numerals for front matter:")
        print("      1. Open in Word")
        print("      2. Insert ‚Üí Break ‚Üí Next Page (before Abstract)")
        print("      3. Format page numbers: front matter = 'i, ii, iii', content = '1, 2, 3'")

    def _add_page_number_field(self, paragraph):
        """
        Add a PAGE field to the given paragraph.

        Word PAGE field format: { PAGE }
        """
        run = paragraph.add_run()

        # Create field begin tag
        fldChar_begin = OxmlElement('w:fldChar')
        fldChar_begin.set(qn('w:fldCharType'), 'begin')

        # Create instruction text
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'PAGE'

        # Create field end tag
        fldChar_end = OxmlElement('w:fldChar')
        fldChar_end.set(qn('w:fldCharType'), 'end')

        # Add to run
        run._r.append(fldChar_begin)
        run._r.append(instrText)
        run._r.append(fldChar_end)


def post_process_docx(docx_path: Path) -> bool:
    """
    Post-process a DOCX file to add advanced formatting.

    Args:
        docx_path: Path to DOCX file to process

    Returns:
        bool: True if successful, False otherwise

    Example:
        >>> post_process_docx(Path('thesis.docx'))
    """
    processor = DOCXPostProcessor(docx_path)
    return processor.process()


if __name__ == '__main__':
    # CLI usage
    import sys
    if len(sys.argv) < 2:
        print("Usage: python docx_postprocessor.py <docx_file>")
        sys.exit(1)

    docx_file = Path(sys.argv[1])
    if not docx_file.exists():
        print(f"Error: File not found: {docx_file}")
        sys.exit(1)

    success = post_process_docx(docx_file)
    sys.exit(0 if success else 1)
