#!/usr/bin/env python3
"""
ABOUTME: Post-processor for DOCX files to add advanced formatting features
ABOUTME: Fixes page numbers, TOC, spacing, indents, section/page breaks after Pandoc generation
"""

from pathlib import Path
from typing import List, Optional
from docx import Document
from docx.shared import Pt, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
from docx.enum.section import WD_SECTION


class DOCXPostProcessor:
    """
    Post-processes DOCX files generated by Pandoc to add features that Pandoc can't create:
    - Page numbers (Roman for front matter, Arabic for content)
    - Table of Contents with clickable links
    - Proper line spacing and indentation
    - Section breaks for different page numbering
    - Page breaks before major sections
    """

    def __init__(self, docx_path: Path):
        """Initialize with path to DOCX file."""
        self.docx_path = docx_path
        self.doc = Document(str(docx_path))

    def _get_style_by_name(self, name: str):
        """Get style by name, handling style name variations."""
        for style in self.doc.styles:
            if style.name == name and style.type == 1:  # Paragraph style
                return style
        return None

    def process(self) -> bool:
        """
        Run all post-processing steps in correct order.

        Returns:
            bool: True if successful, False otherwise
        """
        try:
            print(f"\nüìù Post-processing DOCX: {self.docx_path.name}")
            print()

            # Step 1: Fix paragraph formatting (spacing, indent)
            print("1. Fixing line spacing and indentation...")
            self._fix_paragraph_formatting()

            # Step 2: Insert page break after cover page
            print("2. Separating cover page...")
            self._insert_cover_page_break()

            # Step 3: Insert Table of Contents
            print("3. Adding Table of Contents...")
            self._insert_table_of_contents()

            # Step 4: Insert page breaks before major sections
            print("4. Adding page breaks before major sections...")
            self._insert_section_page_breaks()

            # Step 5: Add section breaks for different page numbering
            print("5. Adding section breaks for page numbering...")
            self._insert_section_breaks()

            # Step 6: Add page numbers
            print("6. Adding page numbers...")
            self._add_page_numbers()

            # Save changes
            self.doc.save(str(self.docx_path))

            print()
            print(f"‚úÖ Post-processing complete: {self.docx_path}")
            return True

        except Exception as e:
            print(f"‚ùå Post-processing failed: {str(e)}")
            import traceback
            traceback.print_exc()
            return False

    def _fix_paragraph_formatting(self):
        """Fix line spacing (2.0) and first-line indent (0.5") for Normal paragraphs."""
        count = 0
        for para in self.doc.paragraphs:
            # Apply to Normal and Body Text styles
            if para.style.name in ['Normal', 'Body Text', 'First Paragraph']:
                pf = para.paragraph_format
                pf.line_spacing = 2.0  # Double spacing
                pf.first_line_indent = Inches(0.5)  # APA standard indent
                pf.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY  # Justified text
                count += 1

        print(f"   ‚úì Fixed {count} paragraphs (2.0 spacing, 0.5\" indent, justified)")

    def _create_sdt_toc_wrapper(self):
        """
        Create SDT (Structured Document Tag) wrapper for Table of Contents.

        This matches Pandoc's native TOC structure and is CRITICAL for Word/LibreOffice
        to recognize and update the TOC. The SDT marks it as a "Table of Contents"
        content control.

        Returns:
            OxmlElement: SDT element with docPartGallery set to "Table of Contents"
        """
        # Create SDT (Structured Document Tag)
        sdt = OxmlElement('w:sdt')

        # Create SDT properties
        sdtPr = OxmlElement('w:sdtPr')

        # Create docPartObj (marks this as a document part)
        docPartObj = OxmlElement('w:docPartObj')

        # Set gallery to "Table of Contents" (this is the key identifier)
        docPartGallery = OxmlElement('w:docPartGallery')
        docPartGallery.set(qn('w:val'), 'Table of Contents')
        docPartObj.append(docPartGallery)

        # Add unique flag (makes this a unique instance)
        docPartUnique = OxmlElement('w:docPartUnique')
        docPartObj.append(docPartUnique)

        # Build hierarchy: sdt ‚Üí sdtPr ‚Üí docPartObj ‚Üí (docPartGallery, docPartUnique)
        sdtPr.append(docPartObj)
        sdt.append(sdtPr)

        # Create SDT content container (TOC paragraphs will go here)
        sdtContent = OxmlElement('w:sdtContent')
        sdt.append(sdtContent)

        return sdt, sdtContent

    def _insert_cover_page_break(self):
        """
        Verify cover page structure (Title, Subtitle, Author, Date).

        Note: Page break after cover page is now handled by _insert_table_of_contents()
        which adds page_break_before=True to the TOC heading. This ensures TOC
        starts on page 2 regardless of where it's inserted.

        This method just verifies the expected cover page elements exist.
        """
        # Find and verify Date paragraph (usually index 3: Title, Subtitle, Author, Date)
        for i, para in enumerate(self.doc.paragraphs):
            if para.style.name == 'Date' or (i <= 5 and 'date' in para.text.lower()):
                print(f"   ‚úì Cover page verified: found Date at paragraph {i}")
                print(f"      Page 1: Title, Subtitle, Author, Date")
                print(f"      Page 2: Table of Contents (page break handled by TOC insertion)")
                return

        # No Date found
        print(f"   ‚ö†Ô∏è  Warning: No Date paragraph found in first 5 paragraphs")
        print(f"      Cover page structure may be non-standard")

    def _insert_table_of_contents(self):
        """
        Insert Table of Contents after cover page using SDT-wrapped Word field code.

        Structure created (matches Pandoc native TOC):
        - Page 1: Cover (Title, Subtitle, Author, Date)
        - Page 2: SDT wrapper containing:
          - TOC heading (with page break)
          - TOC field (with dirty flag)
        - Page 3: Abstract (separate page break added in _insert_section_page_breaks)

        The SDT (Structured Document Tag) wrapper is CRITICAL for Word/LibreOffice
        to recognize this as an updateable Table of Contents content control.
        """
        # Find insertion point (before Abstract/Heading 2)
        insert_index = None
        insertion_para = None
        for i, para in enumerate(self.doc.paragraphs):
            if para.style.name in ['Heading 2', 'Abstract']:
                insert_index = i
                insertion_para = para
                break

        if insert_index is None:
            print("   ‚ö†Ô∏è  Could not find insertion point for TOC (skipping)")
            return

        # Create SDT wrapper
        sdt, sdtContent = self._create_sdt_toc_wrapper()

        # Create TOC heading paragraph
        toc_heading_p = OxmlElement('w:p')

        # Add page break property to heading
        pPr = OxmlElement('w:pPr')
        pageBreakBefore = OxmlElement('w:pageBreakBefore')
        pPr.append(pageBreakBefore)

        # Add style (TOCHeading if available, otherwise centered alignment)
        pStyle = OxmlElement('w:pStyle')
        pStyle.set(qn('w:val'), 'TOCHeading')
        pPr.append(pStyle)

        # Add centered alignment
        jc = OxmlElement('w:jc')
        jc.set(qn('w:val'), 'center')
        pPr.append(jc)

        toc_heading_p.append(pPr)

        # Add heading text run
        r = OxmlElement('w:r')
        rPr = OxmlElement('w:rPr')

        # Bold
        b = OxmlElement('w:b')
        rPr.append(b)

        # Font size 14pt
        sz = OxmlElement('w:sz')
        sz.set(qn('w:val'), '28')  # 14pt * 2
        rPr.append(sz)

        # Font name
        rFonts = OxmlElement('w:rFonts')
        rFonts.set(qn('w:ascii'), 'Times New Roman')
        rFonts.set(qn('w:hAnsi'), 'Times New Roman')
        rPr.append(rFonts)

        r.append(rPr)

        # Add text
        t = OxmlElement('w:t')
        t.text = 'Table of Contents'
        r.append(t)

        toc_heading_p.append(r)

        # Add heading to SDT content
        sdtContent.append(toc_heading_p)

        # Create TOC field paragraph with field structure
        toc_field_p = OxmlElement('w:p')

        # Create run containing TOC field
        r_field = OxmlElement('w:r')

        # Element 1: Field begin with dirty flag
        fldChar_begin = OxmlElement('w:fldChar')
        fldChar_begin.set(qn('w:fldCharType'), 'begin')
        fldChar_begin.set(qn('w:dirty'), 'true')
        r_field.append(fldChar_begin)

        # Element 2: Instruction text
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'TOC \\o "1-3" \\h \\z \\u'
        r_field.append(instrText)

        # Element 3: Field separate
        fldChar_separate = OxmlElement('w:fldChar')
        fldChar_separate.set(qn('w:fldCharType'), 'separate')
        r_field.append(fldChar_separate)

        # Element 4: Field end (NO placeholder text between separate and end)
        fldChar_end = OxmlElement('w:fldChar')
        fldChar_end.set(qn('w:fldCharType'), 'end')
        r_field.append(fldChar_end)

        # Add run to paragraph
        toc_field_p.append(r_field)

        # Add TOC field paragraph to SDT content
        sdtContent.append(toc_field_p)

        # Insert SDT before the Abstract paragraph
        insertion_para._element.addprevious(sdt)

        print(f"   ‚úì Inserted Table of Contents at paragraph {insert_index} (page 2)")
        print(f"   ‚úì TOC wrapped in SDT with docPartGallery='Table of Contents'")

    def _add_toc_field(self, paragraph):
        """
        Add a TOC field to the given paragraph using SDT-compatible structure.

        This matches Pandoc's native TOC field structure exactly:
        - All field elements in a SINGLE run (critical!)
        - w:dirty="true" flag to signal field needs update
        - NO placeholder text between separate and end
        - Field structure: begin ‚Üí instrText ‚Üí separate ‚Üí end

        Word TOC field format: { TOC \\o "1-3" \\h \\z \\u }
        - \\o "1-3": Include heading levels 1-3
        - \\h: Make entries hyperlinks
        - \\z: Hide tab leader and page numbers in web view
        - \\u: Use outline levels (relies on style-based outline levels)
        """
        # Create single run containing all field elements
        run = paragraph.add_run()

        # Element 1: Field begin with dirty flag
        fldChar_begin = OxmlElement('w:fldChar')
        fldChar_begin.set(qn('w:fldCharType'), 'begin')
        fldChar_begin.set(qn('w:dirty'), 'true')  # CRITICAL: signals needs update
        run._r.append(fldChar_begin)

        # Element 2: Instruction text
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'TOC \\o "1-3" \\h \\z \\u'
        run._r.append(instrText)

        # Element 3: Field separate (marks boundary between instruction and result)
        fldChar_separate = OxmlElement('w:fldChar')
        fldChar_separate.set(qn('w:fldCharType'), 'separate')
        run._r.append(fldChar_separate)

        # NO placeholder text here - critical difference from previous implementation
        # Word will auto-populate this when TOC is updated

        # Element 4: Field end
        fldChar_end = OxmlElement('w:fldChar')
        fldChar_end.set(qn('w:fldCharType'), 'end')
        run._r.append(fldChar_end)

    def _insert_section_page_breaks(self):
        """Insert page breaks before major sections (Abstract, Introduction, etc.)."""
        major_sections = [
            'Abstract',
            'Introduction',
            'Literature Review',
            'Theoretical Framework',
            'Methodology',
            'Research Design',
            'Findings',
            'Results',
            'Analysis',
            'Discussion',
            'Conclusion',
            'References',
            'Bibliography',
            'Appendix'
        ]

        count = 0
        for para in self.doc.paragraphs:
            # Check if this is a Heading 2 (major section)
            if para.style.name == 'Heading 2':
                # Check if text matches major section titles
                para_text = para.text.strip()
                if any(section.lower() in para_text.lower() for section in major_sections):
                    para.paragraph_format.page_break_before = True
                    count += 1

        print(f"   ‚úì Added page breaks before {count} major sections")

    def _insert_section_breaks(self):
        """
        Insert section breaks to enable different page numbering:
        - Section 1: Front matter (cover + TOC) - Roman numerals
        - Section 2: Main content - Arabic numerals
        """
        # Find where main content starts (after TOC, at Abstract or Introduction)
        main_content_para_index = None

        for i, para in enumerate(self.doc.paragraphs):
            if para.style.name == 'Heading 2' and 'abstract' in para.text.lower():
                main_content_para_index = i
                break

        if main_content_para_index is None:
            print("   ‚ö†Ô∏è  Could not find main content start (skipping section breaks)")
            return

        # Insert section break before Abstract
        # Note: python-docx doesn't easily support inserting section breaks mid-document
        # So we'll work with existing sections and modify their settings

        # For now, we'll note this limitation
        print(f"   ‚ö†Ô∏è  Section breaks require manual insertion in Word")
        print(f"      (Insert ‚Üí Break ‚Üí Next Page before paragraph {main_content_para_index})")

    def _add_page_numbers(self):
        """
        Add page numbers to footer.

        Note: Ideally we'd have:
        - Section 1 (front matter): Roman numerals (i, ii, iii, iv)
        - Section 2 (main content): Arabic numerals (1, 2, 3...)

        Due to python-docx limitations with section breaks, we'll add simple
        Arabic page numbers for now. Users can customize in Word if needed.
        """
        # Add page number field to first section footer
        for section in self.doc.sections:
            footer = section.footer

            # Clear existing footer content
            for para in footer.paragraphs:
                para.clear()

            # Add centered paragraph with page number
            footer_para = footer.paragraphs[0]
            footer_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

            # Add page number field
            self._add_page_number_field(footer_para)

        print(f"   ‚úì Added page numbers to {len(self.doc.sections)} section(s)")
        print("   ‚ÑπÔ∏è  To add Roman numerals for front matter:")
        print("      1. Open in Word")
        print("      2. Insert ‚Üí Break ‚Üí Next Page (before Abstract)")
        print("      3. Format page numbers: front matter = 'i, ii, iii', content = '1, 2, 3'")

    def _add_page_number_field(self, paragraph):
        """
        Add a PAGE field to the given paragraph.

        Word PAGE field format: { PAGE }
        """
        run = paragraph.add_run()

        # Create field begin tag
        fldChar_begin = OxmlElement('w:fldChar')
        fldChar_begin.set(qn('w:fldCharType'), 'begin')

        # Create instruction text
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'PAGE'

        # Create field end tag
        fldChar_end = OxmlElement('w:fldChar')
        fldChar_end.set(qn('w:fldCharType'), 'end')

        # Add to run
        run._r.append(fldChar_begin)
        run._r.append(instrText)
        run._r.append(fldChar_end)


def post_process_docx(docx_path: Path) -> bool:
    """
    Post-process a DOCX file to add advanced formatting.

    Args:
        docx_path: Path to DOCX file to process

    Returns:
        bool: True if successful, False otherwise

    Example:
        >>> post_process_docx(Path('thesis.docx'))
    """
    processor = DOCXPostProcessor(docx_path)
    return processor.process()


if __name__ == '__main__':
    # CLI usage
    import sys
    if len(sys.argv) < 2:
        print("Usage: python docx_postprocessor.py <docx_file>")
        sys.exit(1)

    docx_file = Path(sys.argv[1])
    if not docx_file.exists():
        print(f"Error: File not found: {docx_file}")
        sys.exit(1)

    success = post_process_docx(docx_file)
    sys.exit(0 if success else 1)
