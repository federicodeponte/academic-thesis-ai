#!/usr/bin/env python3
"""
ABOUTME: Post-processor for DOCX files to add advanced formatting features
ABOUTME: Fixes page numbers, TOC, spacing, indents, section/page breaks after Pandoc generation
"""

from pathlib import Path
from typing import List, Optional
from docx import Document
from docx.shared import Pt, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
from docx.enum.section import WD_SECTION


class DOCXPostProcessor:
    """
    Post-processes DOCX files generated by Pandoc to add features that Pandoc can't create:
    - Page numbers (Roman for front matter, Arabic for content)
    - Table of Contents with clickable links
    - Proper line spacing and indentation
    - Section breaks for different page numbering
    - Page breaks before major sections
    """

    def __init__(self, docx_path: Path):
        """Initialize with path to DOCX file."""
        self.docx_path = docx_path
        self.doc = Document(str(docx_path))

    def _get_style_by_name(self, name: str):
        """Get style by name, handling style name variations."""
        for style in self.doc.styles:
            if style.name == name and style.type == 1:  # Paragraph style
                return style
        return None

    def process(self) -> bool:
        """
        Run all post-processing steps in correct order.

        Returns:
            bool: True if successful, False otherwise
        """
        try:
            print(f"\nüìù Post-processing DOCX: {self.docx_path.name}")
            print()

            # Step 1: Fix paragraph formatting (spacing, indent)
            print("1. Fixing line spacing and indentation...")
            self._fix_paragraph_formatting()

            # Step 2: Fix heading outline levels (CRITICAL for TOC detection)
            print("2. Fixing heading outline levels for TOC detection...")
            self._fix_heading_outline_levels()

            # Step 3: Insert page break after cover page
            print("3. Separating cover page...")
            self._insert_cover_page_break()

            # Step 4: Insert Table of Contents
            print("4. Adding Table of Contents...")
            self._insert_table_of_contents()

            # Step 5: Insert page breaks before major sections
            print("5. Adding page breaks before major sections...")
            self._insert_section_page_breaks()

            # Step 6: Add section breaks for different page numbering
            print("6. Adding section breaks for page numbering...")
            self._insert_section_breaks()

            # Step 7: Add page numbers
            print("7. Adding page numbers...")
            self._add_page_numbers()

            # Save changes
            self.doc.save(str(self.docx_path))

            print()
            print(f"‚úÖ Post-processing complete: {self.docx_path}")
            return True

        except Exception as e:
            print(f"‚ùå Post-processing failed: {str(e)}")
            import traceback
            traceback.print_exc()
            return False

    def _fix_paragraph_formatting(self):
        """Fix line spacing (2.0) and first-line indent (0.5") for Normal paragraphs."""
        count = 0
        for para in self.doc.paragraphs:
            # Apply to Normal and Body Text styles
            if para.style.name in ['Normal', 'Body Text', 'First Paragraph']:
                pf = para.paragraph_format
                pf.line_spacing = 2.0  # Double spacing
                pf.first_line_indent = Inches(0.5)  # APA standard indent
                pf.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY  # Justified text
                count += 1

        print(f"   ‚úì Fixed {count} paragraphs (2.0 spacing, 0.5\" indent, justified)")

    def _fix_heading_outline_levels(self):
        """
        Fix heading paragraphs to include explicit outline levels in paragraph properties.

        CRITICAL for TOC detection: Word/LibreOffice TOC fields require outline levels
        to be explicitly set in paragraph properties, not just inherited from style
        definitions. Pandoc generates headings with style references but doesn't add
        outline levels to paragraph properties.

        Without this fix, TOC fields will be empty even if properly structured because
        they cannot detect any headings.

        Mapping:
        - Heading 1 ‚Üí outline level 0
        - Heading 2 ‚Üí outline level 1 (major sections: Abstract, Introduction, etc.)
        - Heading 3 ‚Üí outline level 2 (subsections)
        - Heading 4-6 ‚Üí outline levels 3-5
        """
        heading_to_level = {
            'Heading 1': 0,
            'Heading 2': 1,
            'Heading 3': 2,
            'Heading 4': 3,
            'Heading 5': 4,
            'Heading 6': 5,
        }

        count = 0
        for para in self.doc.paragraphs:
            style_name = para.style.name if para.style else None

            if style_name in heading_to_level:
                outline_level = heading_to_level[style_name]

                # Get or create paragraph properties element
                pPr = para.paragraph_format._element.get_or_add_pPr()

                # Check if outline level already exists
                existing_outline = pPr.find(qn('w:outlineLvl'))

                if existing_outline is None:
                    # Add outline level element to paragraph properties
                    outlineLvl = OxmlElement('w:outlineLvl')
                    outlineLvl.set(qn('w:val'), str(outline_level))
                    pPr.append(outlineLvl)
                    count += 1

        print(f"   ‚úì Fixed {count} heading paragraphs (added explicit outline levels for TOC)")

    def _insert_cover_page_break(self):
        """
        Verify cover page structure (Title, Subtitle, Author, Date).

        Note: Page break after cover page is now handled by _insert_table_of_contents()
        which adds page_break_before=True to the TOC heading. This ensures TOC
        starts on page 2 regardless of where it's inserted.

        This method just verifies the expected cover page elements exist.
        """
        # Find and verify Date paragraph (usually index 3: Title, Subtitle, Author, Date)
        for i, para in enumerate(self.doc.paragraphs):
            if para.style.name == 'Date' or (i <= 5 and 'date' in para.text.lower()):
                print(f"   ‚úì Cover page verified: found Date at paragraph {i}")
                print(f"      Page 1: Title, Subtitle, Author, Date")
                print(f"      Page 2: Table of Contents (page break handled by TOC insertion)")
                return

        # No Date found
        print(f"   ‚ö†Ô∏è  Warning: No Date paragraph found in first 5 paragraphs")
        print(f"      Cover page structure may be non-standard")

    def _insert_table_of_contents(self):
        """
        Insert Table of Contents after cover page using Word field code.

        Structure created:
        - Page 1: Cover (Title, Subtitle, Author, Date)
        - Page 2: TOC heading + TOC field (this function adds page break here)
        - Page 3: Abstract (separate page break added in _insert_section_page_breaks)
        """
        # Find insertion point (before Abstract/Heading 2)
        insert_index = None
        for i, para in enumerate(self.doc.paragraphs):
            if para.style.name in ['Heading 2', 'Abstract']:
                insert_index = i
                break

        if insert_index is None:
            print("   ‚ö†Ô∏è  Could not find insertion point for TOC (skipping)")
            return

        # Insert TOC heading with page break (starts page 2)
        toc_heading = self.doc.paragraphs[insert_index].insert_paragraph_before()
        toc_heading.text = "Table of Contents"
        toc_heading.alignment = WD_ALIGN_PARAGRAPH.CENTER
        toc_heading.paragraph_format.page_break_before = True  # START PAGE 2 HERE

        # Make heading bold and larger
        if toc_heading.runs:
            run = toc_heading.runs[0]
            run.font.bold = True
            run.font.size = Pt(14)
            run.font.name = 'Times New Roman'

        # Insert TOC field paragraph (on same page as heading)
        toc_para = self.doc.paragraphs[insert_index + 1].insert_paragraph_before()
        self._add_toc_field(toc_para)

        # Note: Page break before Abstract is added by _insert_section_page_breaks()
        # which runs after this method

        print(f"   ‚úì Inserted Table of Contents at paragraph {insert_index} (page 2)")

    def _add_toc_field(self, paragraph):
        """
        Add a TOC field to the given paragraph.

        Word TOC field format requires separate runs for proper field recognition:
        { TOC \\o "1-3" \\h \\z \\u }
        - \\o "1-3": Include heading levels 1-3
        - \\h: Make entries hyperlinks
        - \\z: Hide tab leader and page numbers in web view
        - \\u: Use outline levels

        Note: Each field element MUST be in a separate run for Word to recognize
        it as an updateable field. Missing the "separate" element or combining
        elements in one run causes Word to ignore the field.
        """
        # Run 1: Field begin
        run_begin = paragraph.add_run()
        fldChar_begin = OxmlElement('w:fldChar')
        fldChar_begin.set(qn('w:fldCharType'), 'begin')
        run_begin._r.append(fldChar_begin)

        # Run 2: Instruction text
        run_instr = paragraph.add_run()
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'TOC \\o "1-3" \\h \\z \\u'
        run_instr._r.append(instrText)

        # Run 3: Field separate (CRITICAL - Word won't update without this)
        run_separate = paragraph.add_run()
        fldChar_separate = OxmlElement('w:fldChar')
        fldChar_separate.set(qn('w:fldCharType'), 'separate')
        run_separate._r.append(fldChar_separate)

        # Run 4: Placeholder text (will be replaced when field updates)
        run_text = paragraph.add_run()
        text_elem = OxmlElement('w:t')
        text_elem.text = 'Right-click to update field'
        run_text._r.append(text_elem)

        # Run 5: Field end
        run_end = paragraph.add_run()
        fldChar_end = OxmlElement('w:fldChar')
        fldChar_end.set(qn('w:fldCharType'), 'end')
        run_end._r.append(fldChar_end)

    def _insert_section_page_breaks(self):
        """Insert page breaks before major sections (Abstract, Introduction, etc.)."""
        major_sections = [
            'Abstract',
            'Introduction',
            'Literature Review',
            'Theoretical Framework',
            'Methodology',
            'Research Design',
            'Findings',
            'Results',
            'Analysis',
            'Discussion',
            'Conclusion',
            'References',
            'Bibliography',
            'Appendix'
        ]

        count = 0
        for para in self.doc.paragraphs:
            # Check if this is a Heading 2 (major section)
            if para.style.name == 'Heading 2':
                # Check if text matches major section titles
                para_text = para.text.strip()
                if any(section.lower() in para_text.lower() for section in major_sections):
                    para.paragraph_format.page_break_before = True
                    count += 1

        print(f"   ‚úì Added page breaks before {count} major sections")

    def _insert_section_breaks(self):
        """
        Insert section breaks to enable different page numbering:
        - Section 1: Front matter (cover + TOC) - Roman numerals
        - Section 2: Main content - Arabic numerals
        """
        # Find where main content starts (after TOC, at Abstract or Introduction)
        main_content_para_index = None

        for i, para in enumerate(self.doc.paragraphs):
            if para.style.name == 'Heading 2' and 'abstract' in para.text.lower():
                main_content_para_index = i
                break

        if main_content_para_index is None:
            print("   ‚ö†Ô∏è  Could not find main content start (skipping section breaks)")
            return

        # Insert section break before Abstract
        # Note: python-docx doesn't easily support inserting section breaks mid-document
        # So we'll work with existing sections and modify their settings

        # For now, we'll note this limitation
        print(f"   ‚ö†Ô∏è  Section breaks require manual insertion in Word")
        print(f"      (Insert ‚Üí Break ‚Üí Next Page before paragraph {main_content_para_index})")

    def _add_page_numbers(self):
        """
        Add page numbers to footer.

        Note: Ideally we'd have:
        - Section 1 (front matter): Roman numerals (i, ii, iii, iv)
        - Section 2 (main content): Arabic numerals (1, 2, 3...)

        Due to python-docx limitations with section breaks, we'll add simple
        Arabic page numbers for now. Users can customize in Word if needed.
        """
        # Add page number field to first section footer
        for section in self.doc.sections:
            footer = section.footer

            # Clear existing footer content
            for para in footer.paragraphs:
                para.clear()

            # Add centered paragraph with page number
            footer_para = footer.paragraphs[0]
            footer_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

            # Add page number field
            self._add_page_number_field(footer_para)

        print(f"   ‚úì Added page numbers to {len(self.doc.sections)} section(s)")
        print("   ‚ÑπÔ∏è  To add Roman numerals for front matter:")
        print("      1. Open in Word")
        print("      2. Insert ‚Üí Break ‚Üí Next Page (before Abstract)")
        print("      3. Format page numbers: front matter = 'i, ii, iii', content = '1, 2, 3'")

    def _add_page_number_field(self, paragraph):
        """
        Add a PAGE field to the given paragraph.

        Word PAGE field format: { PAGE }
        """
        run = paragraph.add_run()

        # Create field begin tag
        fldChar_begin = OxmlElement('w:fldChar')
        fldChar_begin.set(qn('w:fldCharType'), 'begin')

        # Create instruction text
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'PAGE'

        # Create field end tag
        fldChar_end = OxmlElement('w:fldChar')
        fldChar_end.set(qn('w:fldCharType'), 'end')

        # Add to run
        run._r.append(fldChar_begin)
        run._r.append(instrText)
        run._r.append(fldChar_end)


def post_process_docx(docx_path: Path) -> bool:
    """
    Post-process a DOCX file to add advanced formatting.

    Args:
        docx_path: Path to DOCX file to process

    Returns:
        bool: True if successful, False otherwise

    Example:
        >>> post_process_docx(Path('thesis.docx'))
    """
    processor = DOCXPostProcessor(docx_path)
    return processor.process()


if __name__ == '__main__':
    # CLI usage
    import sys
    if len(sys.argv) < 2:
        print("Usage: python docx_postprocessor.py <docx_file>")
        sys.exit(1)

    docx_file = Path(sys.argv[1])
    if not docx_file.exists():
        print(f"Error: File not found: {docx_file}")
        sys.exit(1)

    success = post_process_docx(docx_file)
    sys.exit(0 if success else 1)
