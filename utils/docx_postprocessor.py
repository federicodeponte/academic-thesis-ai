#!/usr/bin/env python3
"""
ABOUTME: Post-processor for DOCX files to add advanced formatting features
ABOUTME: Fixes page numbers, TOC, spacing, indents, section/page breaks after Pandoc generation
"""

import re
import uuid
from pathlib import Path
from typing import List, Optional
from docx import Document
from docx.shared import Pt, Inches, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
from docx.enum.section import WD_SECTION
from utils.formatting.academic_formatter import AcademicDocumentFormatter


class DOCXPostProcessor:
    """
    Post-processes DOCX files generated by Pandoc to add features that Pandoc can't create:
    - Page numbers (Roman for front matter, Arabic for content)
    - Table of Contents with clickable links
    - Proper line spacing and indentation
    - Section breaks for different page numbering
    - Page breaks before major sections
    """

    def __init__(self, docx_path: Path):
        """Initialize with path to DOCX file."""
        self.docx_path = docx_path
        self.doc = Document(str(docx_path))

    def _get_style_by_name(self, name: str):
        """Get style by name, handling style name variations."""
        for style in self.doc.styles:
            if style.name == name and style.type == 1:  # Paragraph style
                return style
        return None

    def process(self) -> bool:
        """
        Run all post-processing steps in correct order.

        Returns:
            bool: True if successful, False otherwise
        """
        try:
            print(f"\nüìù Post-processing DOCX: {self.docx_path.name}")
            print()

            # Step 1: Fix paragraph formatting (spacing, indent)
            print("1. Fixing line spacing and indentation...")
            self._fix_paragraph_formatting()

            # Step 2: Convert plain text URLs to clickable hyperlinks
            print("2. Converting URLs to clickable hyperlinks...")
            self._convert_urls_to_hyperlinks()

            # Step 3: Insert page break after cover page
            print("3. Separating cover page...")
            self._insert_cover_page_break()

            # Step 4: Insert Table of Contents
            print("4. Adding Table of Contents...")
            self._insert_table_of_contents()

            # Step 5: Insert page breaks before major sections
            print("5. Adding page breaks before major sections...")
            self._insert_section_page_breaks()

            # Step 6: Add section breaks for different page numbering
            print("6. Adding section breaks for page numbering...")
            self._insert_section_breaks()

            # Step 7: Add page numbers
            print("7. Adding page numbers...")
            self._add_page_numbers()

            # Save changes
            self.doc.save(str(self.docx_path))

            print()
            print(f"‚úÖ Post-processing complete: {self.docx_path}")
            return True

        except Exception as e:
            print(f"‚ùå Post-processing failed: {str(e)}")
            import traceback
            traceback.print_exc()
            return False

    def _fix_paragraph_formatting(self):
        """Fix line spacing (2.0) and first-line indent (0.5") for Normal paragraphs."""
        count = 0
        for para in self.doc.paragraphs:
            # Apply to Normal and Body Text styles
            if para.style.name in ['Normal', 'Body Text', 'First Paragraph']:
                pf = para.paragraph_format
                pf.line_spacing = 2.0  # Double spacing
                pf.first_line_indent = Inches(0.5)  # APA standard indent
                pf.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY  # Justified text
                count += 1

        print(f"   ‚úì Fixed {count} paragraphs (2.0 spacing, 0.5\" indent, justified)")

    def _convert_urls_to_hyperlinks(self):
        """
        Convert plain text URLs to clickable hyperlinks in DOCX.

        FIXED: Issue #2 - Citations had URLs in markdown but weren't clickable in DOCX.
        This converts plain text URLs (especially DOI links) to proper hyperlinks
        matching PDF output (blue, underlined, clickable).

        Uses AcademicDocumentFormatter to detect URLs.
        """
        formatter = AcademicDocumentFormatter()
        url_count = 0

        # URL pattern (matches http:// and https://)
        url_pattern = r'https?://[^\s\)\]<>]+'

        for para in self.doc.paragraphs:
            # Skip if paragraph is empty
            if not para.text.strip():
                continue

            # Check if paragraph contains URLs
            urls_in_para = re.findall(url_pattern, para.text)
            if not urls_in_para:
                continue

            # For each URL found, convert to hyperlink
            for url in urls_in_para:
                try:
                    # Find runs containing the URL
                    para_text = para.text
                    url_start = para_text.find(url)

                    if url_start == -1:
                        continue

                    # Clear existing runs and rebuild with hyperlink
                    url_end = url_start + len(url)
                    text_before = para_text[:url_start]
                    text_after = para_text[url_end:]

                    # Clear paragraph
                    for run in para.runs:
                        run.text = ''

                    # Add text before URL
                    if text_before:
                        para.add_run(text_before)

                    # Add hyperlink
                    self._add_hyperlink(para, url, url)

                    # Add text after URL
                    if text_after:
                        para.add_run(text_after)

                    url_count += 1

                except Exception as e:
                    # Skip this URL if conversion fails
                    continue

        print(f"   ‚úì Converted {url_count} URLs to clickable hyperlinks")

    def _add_hyperlink(self, paragraph, text, url):
        """
        Add a hyperlink to a paragraph.

        Args:
            paragraph: docx.text.paragraph.Paragraph object
            text: Display text for the hyperlink
            url: URL target

        Returns:
            Hyperlink run element
        """
        # Create relationship for hyperlink
        part = paragraph.part
        r_id = part.relate_to(url, 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink', is_external=True)

        # Create hyperlink element
        hyperlink = OxmlElement('w:hyperlink')
        hyperlink.set(qn('r:id'), r_id)

        # Create run element with hyperlink styling
        run = OxmlElement('w:r')
        r_pr = OxmlElement('w:rPr')

        # Style: Blue, underline (standard hyperlink appearance)
        color = OxmlElement('w:color')
        color.set(qn('w:val'), '0563C1')  # Blue color
        r_pr.append(color)

        u = OxmlElement('w:u')
        u.set(qn('w:val'), 'single')
        r_pr.append(u)

        run.append(r_pr)

        # Add text
        text_elem = OxmlElement('w:t')
        text_elem.text = text
        run.append(text_elem)

        hyperlink.append(run)
        paragraph._p.append(hyperlink)

        return hyperlink

    def _create_sdt_toc_wrapper(self):
        """
        Create SDT (Structured Document Tag) wrapper for Table of Contents.

        This matches Pandoc's native TOC structure and is CRITICAL for Word/LibreOffice
        to recognize and update the TOC. The SDT marks it as a "Table of Contents"
        content control.

        Returns:
            OxmlElement: SDT element with docPartGallery set to "Table of Contents"
        """
        # Create SDT (Structured Document Tag)
        sdt = OxmlElement('w:sdt')

        # Create SDT properties
        sdtPr = OxmlElement('w:sdtPr')

        # Create docPartObj (marks this as a document part)
        docPartObj = OxmlElement('w:docPartObj')

        # Set gallery to "Table of Contents" (this is the key identifier)
        docPartGallery = OxmlElement('w:docPartGallery')
        docPartGallery.set(qn('w:val'), 'Table of Contents')
        docPartObj.append(docPartGallery)

        # Add unique flag (makes this a unique instance)
        docPartUnique = OxmlElement('w:docPartUnique')
        docPartObj.append(docPartUnique)

        # Build hierarchy: sdt ‚Üí sdtPr ‚Üí docPartObj ‚Üí (docPartGallery, docPartUnique)
        sdtPr.append(docPartObj)
        sdt.append(sdtPr)

        # Create SDT content container (TOC paragraphs will go here)
        sdtContent = OxmlElement('w:sdtContent')
        sdt.append(sdtContent)

        return sdt, sdtContent

    def _insert_cover_page_break(self):
        """
        Verify cover page structure (Title, Subtitle, Author, Date).

        Note: Page break after cover page is now handled by _insert_table_of_contents()
        which adds page_break_before=True to the TOC heading. This ensures TOC
        starts on page 2 regardless of where it's inserted.

        This method just verifies the expected cover page elements exist.
        """
        # Find and verify Date paragraph (usually index 3: Title, Subtitle, Author, Date)
        for i, para in enumerate(self.doc.paragraphs):
            if para.style.name == 'Date' or (i <= 5 and 'date' in para.text.lower()):
                print(f"   ‚úì Cover page verified: found Date at paragraph {i}")
                print(f"      Page 1: Title, Subtitle, Author, Date")
                print(f"      Page 2: Table of Contents (page break handled by TOC insertion)")
                return

        # No Date found
        print(f"   ‚ö†Ô∏è  Warning: No Date paragraph found in first 5 paragraphs")
        print(f"      Cover page structure may be non-standard")

    def _insert_table_of_contents(self):
        """
        Insert Table of Contents after cover page using SDT-wrapped Word field code.

        Structure created (matches Pandoc native TOC):
        - Page 1: Cover (Title, Subtitle, Author, Date)
        - Page 2: SDT wrapper containing:
          - TOC heading (with page break)
          - TOC field (with dirty flag)
        - Page 3: Abstract (separate page break added in _insert_section_page_breaks)

        The SDT (Structured Document Tag) wrapper is CRITICAL for Word/LibreOffice
        to recognize this as an updateable Table of Contents content control.
        """
        # Find insertion point (before Abstract/Heading 2)
        insert_index = None
        insertion_para = None
        for i, para in enumerate(self.doc.paragraphs):
            if para.style.name in ['Heading 2', 'Abstract']:
                insert_index = i
                insertion_para = para
                break

        if insert_index is None:
            print("   ‚ö†Ô∏è  Could not find insertion point for TOC (skipping)")
            return

        # Create SDT wrapper
        sdt, sdtContent = self._create_sdt_toc_wrapper()

        # Create TOC heading paragraph
        toc_heading_p = OxmlElement('w:p')

        # Add page break property to heading
        pPr = OxmlElement('w:pPr')
        pageBreakBefore = OxmlElement('w:pageBreakBefore')
        pPr.append(pageBreakBefore)

        # Add style (TOCHeading if available, otherwise centered alignment)
        pStyle = OxmlElement('w:pStyle')
        pStyle.set(qn('w:val'), 'TOCHeading')
        pPr.append(pStyle)

        # Add centered alignment
        jc = OxmlElement('w:jc')
        jc.set(qn('w:val'), 'center')
        pPr.append(jc)

        toc_heading_p.append(pPr)

        # Add heading text run
        r = OxmlElement('w:r')
        rPr = OxmlElement('w:rPr')

        # Bold
        b = OxmlElement('w:b')
        rPr.append(b)

        # Font size 14pt
        sz = OxmlElement('w:sz')
        sz.set(qn('w:val'), '28')  # 14pt * 2
        rPr.append(sz)

        # Font name
        rFonts = OxmlElement('w:rFonts')
        rFonts.set(qn('w:ascii'), 'Times New Roman')
        rFonts.set(qn('w:hAnsi'), 'Times New Roman')
        rPr.append(rFonts)

        r.append(rPr)

        # Add text
        t = OxmlElement('w:t')
        t.text = 'Table of Contents'
        r.append(t)

        toc_heading_p.append(r)

        # Add heading to SDT content
        sdtContent.append(toc_heading_p)

        # Create TOC field paragraph with field structure
        toc_field_p = OxmlElement('w:p')

        # Create run containing TOC field
        r_field = OxmlElement('w:r')

        # Element 1: Field begin with dirty flag
        fldChar_begin = OxmlElement('w:fldChar')
        fldChar_begin.set(qn('w:fldCharType'), 'begin')
        fldChar_begin.set(qn('w:dirty'), 'true')
        r_field.append(fldChar_begin)

        # Element 2: Instruction text
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'TOC \\o "1-3" \\h \\z \\u'
        r_field.append(instrText)

        # Element 3: Field separate
        fldChar_separate = OxmlElement('w:fldChar')
        fldChar_separate.set(qn('w:fldCharType'), 'separate')
        r_field.append(fldChar_separate)

        # Element 4: Field end (NO placeholder text between separate and end)
        fldChar_end = OxmlElement('w:fldChar')
        fldChar_end.set(qn('w:fldCharType'), 'end')
        r_field.append(fldChar_end)

        # Add run to paragraph
        toc_field_p.append(r_field)

        # Add TOC field paragraph to SDT content
        sdtContent.append(toc_field_p)

        # Insert SDT before the Abstract paragraph
        insertion_para._element.addprevious(sdt)

        print(f"   ‚úì Inserted Table of Contents at paragraph {insert_index} (page 2)")
        print(f"   ‚úì TOC wrapped in SDT with docPartGallery='Table of Contents'")

    def _add_toc_field(self, paragraph):
        """
        Add a TOC field to the given paragraph using SDT-compatible structure.

        This matches Pandoc's native TOC field structure exactly:
        - All field elements in a SINGLE run (critical!)
        - w:dirty="true" flag to signal field needs update
        - NO placeholder text between separate and end
        - Field structure: begin ‚Üí instrText ‚Üí separate ‚Üí end

        Word TOC field format: { TOC \\o "1-3" \\h \\z \\u }
        - \\o "1-3": Include heading levels 1-3
        - \\h: Make entries hyperlinks
        - \\z: Hide tab leader and page numbers in web view
        - \\u: Use outline levels (relies on style-based outline levels)
        """
        # Create single run containing all field elements
        run = paragraph.add_run()

        # Element 1: Field begin with dirty flag
        fldChar_begin = OxmlElement('w:fldChar')
        fldChar_begin.set(qn('w:fldCharType'), 'begin')
        fldChar_begin.set(qn('w:dirty'), 'true')  # CRITICAL: signals needs update
        run._r.append(fldChar_begin)

        # Element 2: Instruction text
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'TOC \\o "1-3" \\h \\z \\u'
        run._r.append(instrText)

        # Element 3: Field separate (marks boundary between instruction and result)
        fldChar_separate = OxmlElement('w:fldChar')
        fldChar_separate.set(qn('w:fldCharType'), 'separate')
        run._r.append(fldChar_separate)

        # NO placeholder text here - critical difference from previous implementation
        # Word will auto-populate this when TOC is updated

        # Element 4: Field end
        fldChar_end = OxmlElement('w:fldChar')
        fldChar_end.set(qn('w:fldCharType'), 'end')
        run._r.append(fldChar_end)

    def _insert_section_page_breaks(self):
        """Insert page breaks before major sections (Abstract, Introduction, etc.)."""
        major_sections = [
            'Abstract',
            'Introduction',
            'Literature Review',
            'Theoretical Framework',
            'Methodology',
            'Research Design',
            'Findings',
            'Results',
            'Analysis',
            'Discussion',
            'Conclusion',
            'References',
            'Bibliography',
            'Appendix'
        ]

        count = 0
        for para in self.doc.paragraphs:
            # Check if this is a Heading 2 (major section)
            if para.style.name == 'Heading 2':
                # Check if text matches major section titles
                para_text = para.text.strip()
                if any(section.lower() in para_text.lower() for section in major_sections):
                    para.paragraph_format.page_break_before = True
                    count += 1

        print(f"   ‚úì Added page breaks before {count} major sections")

    def _insert_section_breaks(self):
        """
        Insert section breaks to enable different page numbering:
        - Section 1: Front matter (cover + TOC) - Roman numerals
        - Section 2: Main content - Arabic numerals
        """
        # Find where main content starts (after TOC, at Abstract or Introduction)
        main_content_para_index = None

        for i, para in enumerate(self.doc.paragraphs):
            if para.style.name == 'Heading 2' and 'abstract' in para.text.lower():
                main_content_para_index = i
                break

        if main_content_para_index is None:
            print("   ‚ö†Ô∏è  Could not find main content start (skipping section breaks)")
            return

        # Insert section break before Abstract
        # Note: python-docx doesn't easily support inserting section breaks mid-document
        # So we'll work with existing sections and modify their settings

        # For now, we'll note this limitation
        print(f"   ‚ö†Ô∏è  Section breaks require manual insertion in Word")
        print(f"      (Insert ‚Üí Break ‚Üí Next Page before paragraph {main_content_para_index})")

    def _add_page_numbers(self):
        """
        Add page numbers to footer.

        Note: Ideally we'd have:
        - Section 1 (front matter): Roman numerals (i, ii, iii, iv)
        - Section 2 (main content): Arabic numerals (1, 2, 3...)

        Due to python-docx limitations with section breaks, we'll add simple
        Arabic page numbers for now. Users can customize in Word if needed.
        """
        # Add page number field to first section footer
        for section in self.doc.sections:
            footer = section.footer

            # Clear existing footer content
            for para in footer.paragraphs:
                para.clear()

            # Add centered paragraph with page number
            footer_para = footer.paragraphs[0]
            footer_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

            # Add page number field
            self._add_page_number_field(footer_para)

        print(f"   ‚úì Added page numbers to {len(self.doc.sections)} section(s)")
        print("   ‚ÑπÔ∏è  To add Roman numerals for front matter:")
        print("      1. Open in Word")
        print("      2. Insert ‚Üí Break ‚Üí Next Page (before Abstract)")
        print("      3. Format page numbers: front matter = 'i, ii, iii', content = '1, 2, 3'")

    def _add_page_number_field(self, paragraph):
        """
        Add a PAGE field to the given paragraph.

        Word PAGE field format: { PAGE }
        """
        run = paragraph.add_run()

        # Create field begin tag
        fldChar_begin = OxmlElement('w:fldChar')
        fldChar_begin.set(qn('w:fldCharType'), 'begin')

        # Create instruction text
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'PAGE'

        # Create field end tag
        fldChar_end = OxmlElement('w:fldChar')
        fldChar_end.set(qn('w:fldCharType'), 'end')

        # Add to run
        run._r.append(fldChar_begin)
        run._r.append(instrText)
        run._r.append(fldChar_end)


def post_process_docx(docx_path: Path) -> bool:
    """
    Post-process a DOCX file to add advanced formatting.

    Args:
        docx_path: Path to DOCX file to process

    Returns:
        bool: True if successful, False otherwise

    Example:
        >>> post_process_docx(Path('thesis.docx'))
    """
    processor = DOCXPostProcessor(docx_path)
    return processor.process()


if __name__ == '__main__':
    # CLI usage
    import sys
    if len(sys.argv) < 2:
        print("Usage: python docx_postprocessor.py <docx_file>")
        sys.exit(1)

    docx_file = Path(sys.argv[1])
    if not docx_file.exists():
        print(f"Error: File not found: {docx_file}")
        sys.exit(1)

    success = post_process_docx(docx_file)
    sys.exit(0 if success else 1)
